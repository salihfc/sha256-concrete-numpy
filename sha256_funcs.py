import numpy as np
import concrete.numpy as cnp
from sha256_utils import *

def sigma0_32(x): # x is 32-bit
  # ROTR7(x) ^ ROTR18(x) ^ SHR3(x)
  rotr7 = rotr_32bit(x, 7) 
  rotr18 = rotr_32bit(x, 18)
  shr3 = shr_32bit(x, 3)
  return np.bitwise_xor(np.bitwise_xor(rotr7, rotr18), shr3)


"""
    sigma0(x): ROTR7(x) ^ ROTR18(x) ^ SHR3(x)
    sigma0: Array of nibbles -> Array of nibbles
            8 nibbles -> 8 nibbles
    
    Last benchmark: 16.15
"""
def sigma0(x):
    assert x.shape[0] == 8
    mask_4bit = 0b1111

    # Note: For some reason, *8, *4, *2, *1 is faster than <<3, <<2, <<1, <<0 
    # (at least in the case of 4-bit numbers)
    # | //8, //4, //2, //1 is faster than >>3, >>2, >>1, >>0

    result = np.array([
          (((((x[6]//4) & 1) ^ ((x[3]//2) & 1))) * 8 +
          ((((x[6]//2) & 1) ^ ((x[3]   ) & 1))) * 4  +
          ((((x[6]   ) & 1) ^ ((x[4]//8) & 1))) * 2  + 
          ((((x[7]//8) & 1) ^ ((x[4]//4) & 1) ^ ((x[0]//8) & 1)		))) ,

          (((((x[7]//4) & 1) ^ ((x[4]//2) & 1) ^ ((x[0]//4) & 1))) * 8 +
          ((((x[7]//2) & 1) ^ ((x[4]   ) & 1) ^ ((x[0]//2) & 1))) * 4 +
          ((((x[7]   ) & 1) ^ ((x[5]//8) & 1) ^ ((x[0]   ) & 1))) * 2 +
          ((((x[0]//8) & 1) ^ ((x[5]//4) & 1) ^ ((x[1]//8) & 1)))) ,

          (((((x[0]//4) & 1) ^ ((x[5]//2) & 1) ^ ((x[1]//4) & 1))) * 8 +
          ((((x[0]//2) & 1) ^ ((x[5]   ) & 1) ^ ((x[1]//2) & 1))) * 4 +
          ((((x[0]   ) & 1) ^ ((x[6]//8) & 1) ^ ((x[1]   ) & 1))) * 2 +
          ((((x[1]//8) & 1) ^ ((x[6]//4) & 1) ^ ((x[2]//8) & 1)))) ,

          (((((x[1]//4) & 1) ^ ((x[6]//2) & 1) ^ ((x[2]//4) & 1))) * 8 +
          ((((x[1]//2) & 1) ^ ((x[6]   ) & 1) ^ ((x[2]//2) & 1))) * 4 +
          ((((x[1]   ) & 1) ^ ((x[7]//8) & 1) ^ ((x[2]   ) & 1))) * 2 +
          ((((x[2]//8) & 1) ^ ((x[7]//4) & 1) ^ ((x[3]//8) & 1)))) ,

          (((((x[2]//4) & 1) ^ ((x[7]//2) & 1) ^ ((x[3]//4) & 1))) * 8 +
          ((((x[2]//2) & 1) ^ ((x[7]   ) & 1) ^ ((x[3]//2) & 1))) * 4 +
          ((((x[2]   ) & 1) ^ ((x[0]//8) & 1) ^ ((x[3]   ) & 1))) * 2 +
          ((((x[3]//8) & 1) ^ ((x[0]//4) & 1) ^ ((x[4]//8) & 1)))) ,

          (((((x[3]//4) & 1) ^ ((x[0]//2) & 1) ^ ((x[4]//4) & 1))) * 8 +
          ((((x[3]//2) & 1) ^ ((x[0]   ) & 1) ^ ((x[4]//2) & 1))) * 4 +
          ((((x[3]   ) & 1) ^ ((x[1]//8) & 1) ^ ((x[4]   ) & 1))) * 2 +
          ((((x[4]//8) & 1) ^ ((x[1]//4) & 1) ^ ((x[5]//8) & 1)))) ,

          (((((x[4]//4) & 1) ^ ((x[1]//2) & 1) ^ ((x[5]//4) & 1))) * 8 +
          ((((x[4]//2) & 1) ^ ((x[1]   ) & 1) ^ ((x[5]//2) & 1))) * 4 +
          ((((x[4]   ) & 1) ^ ((x[2]//8) & 1) ^ ((x[5]   ) & 1))) * 2 +
          ((((x[5]//8) & 1) ^ ((x[2]//4) & 1) ^ ((x[6]//8) & 1)))) ,

          (((((x[5]//4) & 1) ^ ((x[2]//2) & 1) ^ ((x[6]//4) & 1))) * 8 +
          ((((x[5]//2) & 1) ^ ((x[2]   ) & 1) ^ ((x[6]//2) & 1))) * 4 +
          ((((x[5]   ) & 1) ^ ((x[3]//8) & 1) ^ ((x[6]   ) & 1))) * 2 +
          ((((x[6]//8) & 1) ^ ((x[3]//4) & 1) ^ ((x[7]//8) & 1)))) ,

          # (((((x[6]//4) & 1) ^ ((x[3]//2) & 1)) * 8) +
          # ((((x[6]//2) & 1) ^ ((x[3]   ) & 1))) * 4  +
          # ((((x[6]   ) & 1) ^ ((x[4]//8) & 1))) * 2  + 
          # ((((x[7]//8) & 1) ^ ((x[4]//4) & 1) ^ ((x[0]//8) & 1)		))) ,

          # (((((x[7]//4) & 1) ^ ((x[4]//2) & 1) ^ ((x[0]//4) & 1)) * 8) +
          # ((((x[7]//2) & 1) ^ ((x[4]   ) & 1) ^ ((x[0]//2) & 1))) * 4 +
          # ((((x[7]   ) & 1) ^ ((x[5]//8) & 1) ^ ((x[0]   ) & 1))) * 2 +
          # ((((x[0]//8) & 1) ^ ((x[5]//4) & 1) ^ ((x[1]//8) & 1)))) ,

          # (((((x[0]//4) & 1) ^ ((x[5]//2) & 1) ^ ((x[1]//4) & 1)) * 8) +
          # ((((x[0]//2) & 1) ^ ((x[5]   ) & 1) ^ ((x[1]//2) & 1))) * 4 +
          # ((((x[0]   ) & 1) ^ ((x[6]//8) & 1) ^ ((x[1]   ) & 1))) * 2 +
          # ((((x[1]//8) & 1) ^ ((x[6]//4) & 1) ^ ((x[2]//8) & 1)))) ,

          # (((((x[1]//4) & 1) ^ ((x[6]//2) & 1) ^ ((x[2]//4) & 1)) * 8) +
          # ((((x[1]//2) & 1) ^ ((x[6]   ) & 1) ^ ((x[2]//2) & 1))) * 4 +
          # ((((x[1]   ) & 1) ^ ((x[7]//8) & 1) ^ ((x[2]   ) & 1))) * 2 +
          # ((((x[2]//8) & 1) ^ ((x[7]//4) & 1) ^ ((x[3]//8) & 1)))) ,

          # (((((x[2]//4) & 1) ^ ((x[7]//2) & 1) ^ ((x[3]//4) & 1)) * 8) +
          # ((((x[2]//2) & 1) ^ ((x[7]   ) & 1) ^ ((x[3]//2) & 1))) * 4 +
          # ((((x[2]   ) & 1) ^ ((x[0]//8) & 1) ^ ((x[3]   ) & 1))) * 2 +
          # ((((x[3]//8) & 1) ^ ((x[0]//4) & 1) ^ ((x[4]//8) & 1)))) ,

          # (((((x[3]//4) & 1) ^ ((x[0]//2) & 1) ^ ((x[4]//4) & 1)) * 8) +
          # ((((x[3]//2) & 1) ^ ((x[0]   ) & 1) ^ ((x[4]//2) & 1))) * 4 +
          # ((((x[3]   ) & 1) ^ ((x[1]//8) & 1) ^ ((x[4]   ) & 1))) * 2 +
          # ((((x[4]//8) & 1) ^ ((x[1]//4) & 1) ^ ((x[5]//8) & 1)))) ,

          # (((((x[4]//4) & 1) ^ ((x[1]//2) & 1) ^ ((x[5]//4) & 1)) * 8) +
          # ((((x[4]//2) & 1) ^ ((x[1]   ) & 1) ^ ((x[5]//2) & 1))) * 4 +
          # ((((x[4]   ) & 1) ^ ((x[2]//8) & 1) ^ ((x[5]   ) & 1))) * 2 +
          # ((((x[5]//8) & 1) ^ ((x[2]//4) & 1) ^ ((x[6]//8) & 1)))) ,

          # (((((x[5]//4) & 1) ^ ((x[2]//2) & 1) ^ ((x[6]//4) & 1)) * 8) +
          # ((((x[5]//2) & 1) ^ ((x[2]   ) & 1) ^ ((x[6]//2) & 1))) * 4 +
          # ((((x[5]   ) & 1) ^ ((x[3]//8) & 1) ^ ((x[6]   ) & 1))) * 2 +
          # ((((x[6]//8) & 1) ^ ((x[3]//4) & 1) ^ ((x[7]//8) & 1)))) ,
    ])
    return cnp.array(result)


#########################

def sigma1_32(x):
  rotr17 = rotr_32bit(x, 17)
  rotr19 = rotr_32bit(x, 19)
  rotr10 = rotr_32bit(x, 10)

  return np.bitwise_xor(np.bitwise_xor(rotr17, rotr19), rotr10)


# 17.11590678691864 [>>]
# 15.18837687969207 [//]
def sigma1(x):
    
    assert x.shape[0] == 8
    result = np.array([
          ((((x[3]   ) & 1) ^ ((x[3]//4) & 1))) * 8 +
          ((((x[4]//8) & 1) ^ ((x[3]//2) & 1))) * 4 +
          ((((x[4]//4) & 1) ^ ((x[3]   ) & 1))) * 2 +
          ((((x[4]//2) & 1) ^ ((x[4]//8) & 1))),

          ((((x[4]   ) & 1) ^ ((x[4]//4) & 1))) * 8 +
          ((((x[5]//8) & 1) ^ ((x[4]//2) & 1))) * 4 +
          ((((x[5]//4) & 1) ^ ((x[4]   ) & 1))) * 2 +
          ((((x[5]//2) & 1) ^ ((x[5]//8) & 1))),

          ((((x[5]   ) & 1) ^ ((x[5]//4) & 1))) * 8 +
          ((((x[6]//8) & 1) ^ ((x[5]//2) & 1))) * 4 +
          ((((x[6]//4) & 1) ^ ((x[5]   ) & 1) ^ ((x[0] // 8) & 1)) ) * 2 +
          ((((x[6]//2) & 1) ^ ((x[6]//8) & 1) ^ ((x[0] // 4) & 1))),

          ((((x[6]   ) & 1) ^ ((x[6]//4) & 1) ^ ((x[0] // 2) & 1)) ) * 8 +
          ((((x[7]//8) & 1) ^ ((x[6]//2) & 1) ^ ((x[0]     ) & 1)) ) * 4 +
          ((((x[7]//4) & 1) ^ ((x[6]   ) & 1) ^ ((x[1] // 8) & 1)) ) * 2 +
          ((((x[7]//2) & 1) ^ ((x[7]//8) & 1) ^ ((x[1] // 4) & 1))),

          ((((x[7]   ) & 1) ^ ((x[7]//4) & 1) ^ ((x[1] // 2) & 1)) ) * 8 +
          ((((x[0]//8) & 1) ^ ((x[7]//2) & 1) ^ ((x[1]     ) & 1)) ) * 4 +
          ((((x[0]//4) & 1) ^ ((x[7]   ) & 1) ^ ((x[2] // 8) & 1)) ) * 2 +
          ((((x[0]//2) & 1) ^ ((x[0]//8) & 1) ^ ((x[2] // 4) & 1))),

          ((((x[0]   ) & 1) ^ ((x[0]//4) & 1) ^ ((x[2] // 2) & 1)) ) * 8 +
          ((((x[1]//8) & 1) ^ ((x[0]//2) & 1) ^ ((x[2]     ) & 1)) ) * 4 +
          ((((x[1]//4) & 1) ^ ((x[0]   ) & 1) ^ ((x[3] // 8) & 1)) ) * 2 +
          ((((x[1]//2) & 1) ^ ((x[1]//8) & 1) ^ ((x[3] // 4) & 1))),

          ((((x[1]   ) & 1) ^ ((x[1]//4) & 1) ^ ((x[3] // 2) & 1)) ) * 8 +
          ((((x[2]//8) & 1) ^ ((x[1]//2) & 1) ^ ((x[3]     ) & 1)) ) * 4 +
          ((((x[2]//4) & 1) ^ ((x[1]   ) & 1) ^ ((x[4] // 8) & 1)) ) * 2 +
          ((((x[2]//2) & 1) ^ ((x[2]//8) & 1) ^ ((x[4] // 4) & 1))),

          ((((x[2]   ) & 1) ^ ((x[2]//4) & 1) ^ ((x[4] // 2) & 1)) ) * 8 +
          ((((x[3]//8) & 1) ^ ((x[2]//2) & 1) ^ ((x[4]     ) & 1)) ) * 4 +
          ((((x[3]//4) & 1) ^ ((x[2]   ) & 1) ^ ((x[5] // 8) & 1)) ) * 2 +
          ((((x[3]//2) & 1) ^ ((x[3]//8) & 1) ^ ((x[5] // 4) & 1))),
        ]
    )

    return (result)

#########################

def create_working_next(working, t1, t2):
    # working_next = cnp.zeros(working.shape)
    working_next = np.zeros_like(working)
    # working_next = np.full_like(working, 0xf)
    # print ("working_next is:", working_next.shape)

    working_next[0] = add_modulo_32(t1, t2)
    working_next[1] = working[0]
    working_next[2] = working[1]
    working_next[3] = working[2]
    working_next[4] = add_modulo_32(working[3], t1)
    working_next[5] = working[4]
    working_next[6] = working[5]
    working_next[7] = working[6]
    # return (working_next)
    return working_next


"""
    x : 8 x 4bit array
    y : 8 x 4bit array
    output : 8 x 4bit array > (x + y) % 2^32
"""
# def real_add_modulo_4(x, y, carry):
# 	return (x + y + carry) & 0b1111

# def real_carry_modulo_4(x, y, carry):
# 	return ((x + y + carry) >> 4) & 0b1


# def encode_index(left, right, carry):
# 	return (carry << 8) | (left << 4) | (right)

# # indexing : [carry][left][right]
# table_add_modulo_4 = cnp.LookupTable(
# 	[
# 		real_add_modulo_4(left, right, carry) 
# 			for carry in range(2)
# 				for left in range(16)
# 					for right in range(16)
# 	]
# )

# table_carry_modulo_4 = cnp.LookupTable(
# 	[
# 		real_carry_modulo_4(left, right, carry)
# 			for carry in range(2)
# 				for left in range(16)
# 					for right in range(16)
# 	]
# )


# def tlu_add_modulo_4(x, y, carry):
# 	return table_add_modulo_4[encode_index(x, y, carry)]


# def tlu_carry_modulo_4(x, y, carry):
# 	return table_carry_modulo_4[encode_index(x, y, carry)]


# def add_modulo_32(x, y):
# 		z = cnp.zeros(x.shape)
# 		carry = 0

# 		# process from 7 to 0 [x[0] is most significant]
# 		for i in range(7, -1, -1):
# 				sum = real_add_modulo_4(x[i], y[i], carry)
# 				next_carry = real_carry_modulo_4(x[i], y[i], carry)
# 				z[i] = sum
# 				carry = next_carry

# 		return z 

def add_modulo_32_encoded(x, y):
    z = cnp.zeros(x.shape)
    carry = cnp.zeros(x[0].shape)

    # process from 7 to 0 [x[0] is most significant]
    for i in range(7, -1, -1):
        sum = add_modulo_32_multiple(np.array([x[i], y[i], carry], dtype=object))
        # sum = x[i] + y[i] + carry
        z[i] = sum & 0xf
        carry = sum >> 4

    return z 


def add_modulo_32(x, y):
    z = cnp.zeros(x.shape)
    carry = cnp.zero()

    # process from 7 to 0 [x[0] is most significant]
    for i in range(7, -1, -1):
        sum = x[i] + y[i] + carry
        z[i] = sum & 0xf
        carry = sum >> 4

    return z 


def add_modulo_32_multiple(elements):
    element_count = len(elements)
    z = cnp.zeros(elements[0].shape)
    carry = cnp.zero()

    # process from 7 to 0 [x[0] is most significant]
    for i in range(7, -1, -1):
        sum = np.sum(elements[j][i] for j in range(element_count)) + carry
        z[i] = sum & 0xf
        carry = sum >> 4

    return z




"""
    x : 8x8 x 4bit array
    y : 8x8 x 4bit array
    output : 8x8 x 4bit array > (x + y) % 2^32
"""
def add_modulo_32_2d(x, y):
    z = cnp.zeros(x.shape)
    # carry = cnp.zeros(x.shape[0])
    carry = np.zeros(x.shape[0])

    # process from 7 to 0 [x[0] is most significant]
    for i in range(7, -1, -1):
        sum = x[:, i] + y[:, i] + carry
        # print("x: ", x[:, i].shape)
        # print("y: ", x[:, i].shape)
        # print("carry: ", carry.shape)
        # print("sum: ", sum.shape)
        next_carry = np.greater(sum, 0xf)
        z[:, i] = sum - (next_carry * 16)
        carry = next_carry

    return z

def ch(x, y, z):
    left = x & y
    mask = 0xf
    not_x = mask - (x & mask)
    right = not_x & z
    return left ^ right


def maj(x, y, z):
    return (x & y) ^ (x & z) ^ (y & z)


def get_bit(x, t, i):
    return (x[t] >> i) & 1


#########################

def big_sigma0_32(x):
    # return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22)
    rotr2 = rotr_32bit(x, 2)
    rotr13 = rotr_32bit(x, 13)
    rotr22 = rotr_32bit(x, 22)
    return np.bitwise_xor(np.bitwise_xor(rotr2, rotr13), rotr22)

# get_bit: 19.219149041175843
# [*] : 16.464954566955566
# [remove get_bit] : 11.454
def big_sigma0(x):
    result = np.array([
          (((x[7] // 2) & 1) ^ ((x[4]     ) & 1) ^ ((x[2] // 2) & 1))  * 8 +
          (((x[7]     ) & 1) ^ ((x[5] // 8) & 1) ^ ((x[2]     ) & 1))  * 4 +
          (((x[0] // 8) & 1) ^ ((x[5] // 4) & 1) ^ ((x[3] // 8) & 1))  * 2 +
          (((x[0] // 4) & 1) ^ ((x[5] // 2) & 1) ^ ((x[3] // 4) & 1)),

          (((x[0] // 2) & 1) ^ ((x[5]     ) & 1) ^ ((x[3] // 2) & 1))  * 8 +
          (((x[0]     ) & 1) ^ ((x[6] // 8) & 1) ^ ((x[3]     ) & 1))  * 4 +
          (((x[1] // 8) & 1) ^ ((x[6] // 4) & 1) ^ ((x[4] // 8) & 1))  * 2 +
          (((x[1] // 4) & 1) ^ ((x[6] // 2) & 1) ^ ((x[4] // 4) & 1)),

          (((x[1] // 2) & 1) ^ ((x[6]     ) & 1) ^ ((x[4] // 2) & 1))  * 8 +
          (((x[1]     ) & 1) ^ ((x[7] // 8) & 1) ^ ((x[4]     ) & 1))  * 4 +
          (((x[2] // 8) & 1) ^ ((x[7] // 4) & 1) ^ ((x[5] // 8) & 1))  * 2 +
          (((x[2] // 4) & 1) ^ ((x[7] // 2) & 1) ^ ((x[5] // 4) & 1)),
          
          (((x[2] // 2) & 1) ^ ((x[7]     ) & 1) ^ ((x[5] // 2) & 1))  * 8 +
          (((x[2]     ) & 1) ^ ((x[0] // 8) & 1) ^ ((x[5]     ) & 1))  * 4 +
          (((x[3] // 8) & 1) ^ ((x[0] // 4) & 1) ^ ((x[6] // 8) & 1))  * 2 +
          (((x[3] // 4) & 1) ^ ((x[0] // 2) & 1) ^ ((x[6] // 4) & 1)),

          (((x[3] // 2) & 1) ^ ((x[0]     ) & 1) ^ ((x[6] // 2) & 1))  * 8 +
          (((x[3]     ) & 1) ^ ((x[1] // 8) & 1) ^ ((x[6]     ) & 1))  * 4 +
          (((x[4] // 8) & 1) ^ ((x[1] // 4) & 1) ^ ((x[7] // 8) & 1))  * 2 +
          (((x[4] // 4) & 1) ^ ((x[1] // 2) & 1) ^ ((x[7] // 4) & 1)),

          (((x[4] // 2) & 1) ^ ((x[1]     ) & 1) ^ ((x[7] // 2) & 1))  * 8 +
          (((x[4]     ) & 1) ^ ((x[2] // 8) & 1) ^ ((x[7]     ) & 1))  * 4 +
          (((x[5] // 8) & 1) ^ ((x[2] // 4) & 1) ^ ((x[0] // 8) & 1))  * 2 +
          (((x[5] // 4) & 1) ^ ((x[2] // 2) & 1) ^ ((x[0] // 4) & 1)),

          (((x[5] // 2) & 1) ^ ((x[2]     ) & 1) ^ ((x[0] // 2) & 1))  * 8 +
          (((x[5]     ) & 1) ^ ((x[3] // 8) & 1) ^ ((x[0]     ) & 1))  * 4 +
          (((x[6] // 8) & 1) ^ ((x[3] // 4) & 1) ^ ((x[1] // 8) & 1))  * 2 +
          (((x[6] // 4) & 1) ^ ((x[3] // 2) & 1) ^ ((x[1] // 4) & 1)),

          (((x[6] // 2) & 1) ^ ((x[3]     ) & 1) ^ ((x[1] // 2) & 1))  * 8 +
          (((x[6]     ) & 1) ^ ((x[4] // 8) & 1) ^ ((x[1]     ) & 1))  * 4 +
          (((x[7] // 8) & 1) ^ ((x[4] // 4) & 1) ^ ((x[2] // 8) & 1))  * 2 +
          (((x[7] // 4) & 1) ^ ((x[4] // 2) & 1) ^ ((x[2] // 4) & 1)),
    ])

    assert result.shape == (8,)
    # return (result)
    return result


def big_sigma1_32(x):
  # return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25)
  rotr6 = rotr_32bit(x, 6)
  rotr11 = rotr_32bit(x, 11)
  rotr25 = rotr_32bit(x, 25)
  return np.bitwise_xor(np.bitwise_xor(rotr6, rotr11), rotr25)


def big_sigma1(x):

    # result size: (8,)
    result = np.array([
      (((x[6] // 2) & 1) ^ ((x[5] // 4) & 1) ^ ((x[1]     ) & 1))  * 8 +
      (((x[6]     ) & 1) ^ ((x[5] // 2) & 1) ^ ((x[2] // 8) & 1))  * 4 +
      (((x[7] // 8) & 1) ^ ((x[5]     ) & 1) ^ ((x[2] // 4) & 1))  * 2 +
      (((x[7] // 4) & 1) ^ ((x[6] // 8) & 1) ^ ((x[2] // 2) & 1)),

      (((x[7] // 2) & 1) ^ ((x[6] // 4) & 1) ^ ((x[2]     ) & 1))  * 8 +
      (((x[7]     ) & 1) ^ ((x[6] // 2) & 1) ^ ((x[3] // 8) & 1))  * 4 +
      (((x[0] // 8) & 1) ^ ((x[6]     ) & 1) ^ ((x[3] // 4) & 1))  * 2 +
      (((x[0] // 4) & 1) ^ ((x[7] // 8) & 1) ^ ((x[3] // 2) & 1)),

      (((x[0] // 2) & 1) ^ ((x[7] // 4) & 1) ^ ((x[3]     ) & 1))  * 8 +
      (((x[0]     ) & 1) ^ ((x[7] // 2) & 1) ^ ((x[4] // 8) & 1))  * 4 +
      (((x[1] // 8) & 1) ^ ((x[7]     ) & 1) ^ ((x[4] // 4) & 1))  * 2 +
      (((x[1] // 4) & 1) ^ ((x[0] // 8) & 1) ^ ((x[4] // 2) & 1)),

      (((x[1] // 2) & 1) ^ ((x[0] // 4) & 1) ^ ((x[4]     ) & 1))  * 8 +
      (((x[1]     ) & 1) ^ ((x[0] // 2) & 1) ^ ((x[5] // 8) & 1))  * 4 +
      (((x[2] // 8) & 1) ^ ((x[0]     ) & 1) ^ ((x[5] // 4) & 1))  * 2 +
      (((x[2] // 4) & 1) ^ ((x[1] // 8) & 1) ^ ((x[5] // 2) & 1)),

      (((x[2] // 2) & 1) ^ ((x[1] // 4) & 1) ^ ((x[5]     ) & 1))  * 8 +
      (((x[2]     ) & 1) ^ ((x[1] // 2) & 1) ^ ((x[6] // 8) & 1))  * 4 +
      (((x[3] // 8) & 1) ^ ((x[1]     ) & 1) ^ ((x[6] // 4) & 1))  * 2 +
      (((x[3] // 4) & 1) ^ ((x[2] // 8) & 1) ^ ((x[6] // 2) & 1)),

      (((x[3] // 2) & 1) ^ ((x[2] // 4) & 1) ^ ((x[6]     ) & 1))  * 8 +
      (((x[3]     ) & 1) ^ ((x[2] // 2) & 1) ^ ((x[7] // 8) & 1))  * 4 +
      (((x[4] // 8) & 1) ^ ((x[2]     ) & 1) ^ ((x[7] // 4) & 1))  * 2 +
      (((x[4] // 4) & 1) ^ ((x[3] // 8) & 1) ^ ((x[7] // 2) & 1)),

      (((x[4] // 2) & 1) ^ ((x[3] // 4) & 1) ^ ((x[7]     ) & 1))  * 8 +
      (((x[4]     ) & 1) ^ ((x[3] // 2) & 1) ^ ((x[0] // 8) & 1))  * 4 +
      (((x[5] // 8) & 1) ^ ((x[3]     ) & 1) ^ ((x[0] // 4) & 1))  * 2 +
      (((x[5] // 4) & 1) ^ ((x[4] // 8) & 1) ^ ((x[0] // 2) & 1)),

      (((x[5] // 2) & 1) ^ ((x[4] // 4) & 1) ^ ((x[0]     ) & 1))  * 8 +
      (((x[5]     ) & 1) ^ ((x[4] // 2) & 1) ^ ((x[1] // 8) & 1))  * 4 +
      (((x[6] // 8) & 1) ^ ((x[4]     ) & 1) ^ ((x[1] // 4) & 1))  * 2 +
      (((x[6] // 4) & 1) ^ ((x[5] // 8) & 1) ^ ((x[1] // 2) & 1)),
    ])

    # return (result)
    return result
    # return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25)